<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립트 :: 데이터 실행하기</title>

    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/default.min.css">
</head>

<body>
    <header id="header">
        <h1>
            <a href="index.html">javascript</a>
        </h1>
        <nav>
            <ul>
                <li><a href="javascript01.html">데이터 저장하기</a></li>
                <li><a href="javascript02.html">데이터 불러오기</a></li>
                <li class="active"><a href="javascript03.html">데이터 실행하기</a></li>
                <li><a href="javascript04.html">데이터 제어하기</a></li>
            </ul>
            <ul>
                <li><a href="object01.html">문자열 객체</a></li>
                <li><a href="object02.html">배열 객체</a></li>
                <li><a href="object03.html">수학 객체</a></li>
                <li><a href="object04.html">숫자 객체</a></li>
                <li><a href="object05.html">브라우저 객체</a></li>
                <li><a href="object06.html">요소 객체</a></li>
                <li><a href="object07.html">이벤트 객체</a></li>
            </ul>
        </nav>
    </header>
    <!-- //header -->

    <main id="main">
        <div class="main__menu container">
            <ul>
                <li><a href="#sample01">01. 함수 : 선언적 함수</a></li>
                <li><a href="#sample02">02. 함수 : 익명 함수</a></li>
                <li><a href="#sample03">03. 함수 : 매개변수 함수</a></li>
                <li><a href="#sample04">04. 함수 : 리턴값 함수</a></li>
                <li><a href="#sample05">05. 함수 : 매개함수 + 리턴값 함수</a></li>
                <li><a href="#sample06">06. 화살표 함수 : 선언적 함수</a></li>
                <li><a href="#sample07">07. 화살표 함수 : 익명 함수</a></li>
                <li><a href="#sample08">08. 화살표 함수 : 매개변수 함수</a></li>
                <li><a href="#sample09">09. 화살표 함수 : 리턴값 함수</a></li>
                <li><a href="#sample10">10. 화살표 함수 : 매개함수 + 리턴값 함수</a></li>
                <li><a href="#sample11">11. 함수 유형 : 함수와 매개변수를 이용한 형태</a></li>
                <li><a href="#sample12">12. 함수 유형 : 함수와 변수를 이용한 형태</a></li>
                <li><a href="#sample13">13. 함수 유형 : 함수와 배열을 이용한 형태</a></li>
                <li><a href="#sample14">14. 함수 유형 : 함수와 객체를 이용한 형태</a></li>
                <li><a href="#sample15">15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</a></li>
                <li><a href="#sample16">16. 함수 유형 : 객체 안에 함수를 이용한 형태</a></li>
                <li><a href="#sample17">17. 함수 유형 : 객체 생성자 함수</a></li>
                <li><a href="#sample18">18. 함수 유형 : 프로토타입 함수</a></li>
                <li><a href="#sample19">19. 함수 유형 : 객체 리터릴 함수</a></li>
                <li><a href="#sample20">20. 함수 : 즉시실행 함수</a></li>
                <li><a href="#sample21">21. 함수 : 피라미터 함수</a></li>
                <li><a href="#sample22">22. 함수 : 재귀 함수</a></li>
                <li><a href="#sample23">23. 함수 : 콜백 함수</a></li>
                <li><a href="#sample24">24. 함수 : 비동기 방식 : 콜백 함수</a></li>
                <li><a href="#sample25">25. 함수 : 비동기 방식 : 프로미스</a></li>
                <li><a href="#sample26">26. 함수 : 비동기 방식 : asyne/await</a></li>
                <li><a href="#sample27">27. 함수 : 중첩 함수</a></li>
                <li><a href="#sample28">28. 함수 : 클로저</a></li>
                <li><a href="#sample29">29. 클래스 : 기본</a></li>
                <li><a href="#sample30">30. 클래스 : 상속</a></li>
            </ul>
        </div>
        <!-- //main__menu -->


        <div class="main__sample container">
            <div id="sample01" class="sample">
                <h3>01. 함수 : 선언적 함수</h3>
                <p>
                    선언적 함수(Declarative function)는 프로그래밍 언어에서 함수를 선언할 때 사용되는 방식 중 하나입니다. 이 방식은 함수의 이름과 내용을 명시적으로 선언하여 함수를
                    정의합니다.<br>
                    선언적 함수는 코드의 가독성을 높이고, 프로그램 구조를 명확하게 만들어 줍니다. 함수의 이름을 명시적으로 지정하고 함수의 내용을 정의함으로써 코드를 이해하고 유지 보수하기 쉽게
                    만들어 줍니다.
                </p>
                <pre><code>{
function func() {
    console.log("01. 함수가 실행되었습니다.");
}
func();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            01. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample02 -->
        </div>

        <div class="main__sample container">
            <div id="sample02" class="sample">
                <h3>02. 함수 : 익명 함수</h3>
                <p>
                    익명 함수(Anonymous function)는 이름이 없는 함수를 의미합니다. 일반적으로 프로그래밍 언어에서 함수는 함수명을 가지고 있어서 함수를 정의하고 호출할 때 그 함수명을
                    사용합니다. 그러나 익명 함수는 이름 없이 정의되며, 주로 다른 함수의 매개변수로 전달되거나, 함수 내부에서 간단한 연산을 수행할 때 사용됩니다.
                </p>
                <pre><code>{

const func = function () {
    console.log("02. 함수가 실행되었습니다.");
}
func();

}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            02. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample02 -->
        </div>

        <div class="main__sample container">
            <div id="sample03" class="sample">
                <h3>03. 함수 : 매개변수 함수</h3>
                <p>
                    매개변수는 함수 내에서 사용될 입력값을 정의하는 변수입니다. 함수를 호출할 때 매개변수로 전달된 실제 값을 인수(argument)라고 합니다.
                    *명명된 함수와 매개변수*
                    첫 번째 예에서 func라는 이름의 함수를 정의하고 있습니다.
                    이 함수는 str이라는 이름의 매개변수를 받습니다. 함수 내부에서는 console.log(str);를 통해 매개변수 str에 저장된 값을 콘솔에 출력합니다. func("03 함수가
                    실행되었습니다.");라는 코드로 함수를 호출할 때, "03 함수가 실행되었습니다."라는 문자열이 str 매개변수로 전달되어 함수 내에서 출력됩니다.
                </p>
                <pre><code>{

//선언적 함수
function func(str) {
    console.log(str);
}
func("03. 함수가 실행되었습니다.");

//익명 함수
const func1 = function (str) {
    console.log(str);
}
func1("03. 함수가 실행되었습니다.");

}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            03. 함수가 실행되었습니다.<br>
                            03. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample03 -->
        </div>

        <div class="main__sample container">
            <div id="sample04" class="sample">
                <h3>04. 함수 : 리턴값 함수</h3>
                <p>
                    리턴값 함수(Return value function)는 함수가 실행된 후 결과를 반환하는 함수를 가리킵니다. 함수가 작업을 수행한 후 그 결과를 호출자(caller)에게
                    반환(return)하는 것이 리턴값 함수의 특징입니다. 반환되는 값은 함수가 실행된 결과이며, 호출자는 이 값을 이용하여 필요한 작업을 계속할 수 있습니다.
                </p>
                <pre><code>{

//선언적 함수
function func() {
    return "04. 함수가 실행되었습니다."
}
console.log(func());

//익명 함수
const func1 = function () {
    return "04. 함수가 실행되었습니다."
}
console.log(func1());

}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            04. 함수가 실행되었습니다.<br>
                            04. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample04 -->
        </div>

        <div class="main__sample container">
            <div id="sample05" class="sample">
                <h3>05. 함수 : 매개함수 + 리턴값 함수</h3>
                <p>
                    "함수 : 매개함수 + 리턴값 함수"라는 용어는 함수에 관한 두 가지 중요한 측면을 강조하는 것으로 이해할 수 있습니다.

                    매개함수(Parameter): 함수에게 입력으로 전달되는 값을 말합니다. 이것은 함수가 작업을 수행하기 위해 필요한 데이터를 함수 내부로 전달하는 방법입니다. 매개변수는 함수를
                    호출할 때 전달되며, 함수 내부에서 이러한 값들은 변수로 사용됩니다.

                    리턴값(Return Value): 함수가 실행을 마친 후에 반환하는 값을 의미합니다. 이것은 함수가 작업을 완료하고 호출자에게 결과를 돌려주는 방법입니다. 함수는 작업을 마친 후에
                    결과값을 반환하며, 호출자는 이 값을 이용하여 필요한 작업을 수행할 수 있습니다.

                    함수가 매개변수를 받고 리턴값을 가지는 것은 매우 일반적입니다. 예를 들어, 두 숫자를 더하는 함수를 생각해보겠습니다. 이 함수는 두 개의 숫자를 매개변수로 받아들이고, 그들을
                    더한 결과를 반환합니다.
                    str은 매개변수(parameter)라는 뜻으로 함수를 호출할 때 전달되는 값(argument)을 받아들이는 변수입니다.
                    func와 결과값인 console.log()에 동일하게 매개변수인 str을 입력하여 선언한 후 func() & func1()에 결과값을 지정합니다.
                    이 때, 리턴값을 동시에 선언하고 있기 때문에 return 값은 매개변수인 str로 지정해야합니다.
                </p>
                <pre><code>{

//선언적 함수
function func(str) {
    return str;
}
console.log(func("05. 함수가 실행되었습니다."))
//익명함수
const func1 = function (str) {
    return str;
}
console.log(func1("05. 함수가 실행되었습니다."))
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            05. 함수가 실행되었습니다.<br>
                            05. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample01 -->
        </div>

        <div class="main__sample container">
            <div id="sample06" class="sample">
                <h3>06. 화살표 함수 : 선언적 함수</h3>
                <p>
                    화살표 함수(Arrow function)는 JavaScript에서의 함수를 간단하게 정의하는 방법 중 하나입니다. 화살표 함수는 함수 표현식을 간결하게 작성할 수 있도록 해주며,
                    함수의 선언을 축약하여 사용할 수 있습니다.<br>

                    화살표 함수는 보통 "선언적 함수(Declarative function)"와 대비되는 개념으로 사용됩니다. 선언적 함수는 기존의 function 키워드를 사용하여 함수를 선언하는
                    방식을 말합니다.
                    기존 선언적 함수에서 function을 지운 후 func와 () 사이엔 '=' ,()와 {} 사이엔 '=>'를 입력합니다.
                </p>
                <pre><code>{
// 기존 선언적 함수
function func() {
    console.log("06. 함수가 실행되었습니다.");
}
func();

// 화살표 선언적 함수
func1 = () => {
    console.log("06. 함수가 실행되었습니다.");
}
func1();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            06. 함수가 실행되었습니다.<br>
                            06. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample01 -->
        </div>

        <div class="main__sample container">
            <div id="sample07" class="sample">
                <h3>07. 화살표 함수 : 익명 함수</h3>
                <p>
                    선언적 함수(declarative function)는 명령형 프로그래밍의 반대 개념으로, 어떻게 해야 하는지를 명시하는 대신에 원하는 결과를 설명하는 방식으로 작성된 함수를
                    의미합니다. 즉, 선언적 함수는 함수의 구현에 대한 세부 정보를 명시적으로 제공하지 않고도 작업을 수행할 수 있도록 해줍니다. 기존 익명 함수에서 function을 지운 후
                    func1과 () 사이엔 '=' ,()와 {} 사이엔 '=>'를 입력합니다.
                </p>
                <pre><code>{
// 기존 익명 함수
const func = function () {
    console.log("07. 함수가 실행되었습니다.");
}
func();

// 화살표 익명 함수
const func1 = () => {
    console.log("07. 함수가 실행되었습니다.");
}
func1();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            07. 함수가 실행되었습니다.<br>
                            07. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample01 -->
        </div>

        <div class="main__sample container">
            <div id="sample08" class="sample">
                <h3>08. 화살표 함수 : 매개변수 함수</h3>
                <p>
                    함수가 매개변수를 받아들이는 것은 함수를 호출할 때 함수로 전달되는 값을 의미합니다. 이 매개변수들은 함수 내에서 사용될 수 있고, 함수의 동작을 제어하거나 외부에서 전달된 값을
                    처리하는 데 사용됩니다. 기존 매개변수 함수에서 function을 지운 후 func1과 () 사이엔 '=' ,()와 {} 사이엔 '=>'를 입력합니다.
                </p>
                <pre><code>{
// 기존 매개변수 함수
function func = (str){
    console.log(str);
}
func("08. 함수가 실행되었습니다.");

// 화살표 매개변수 함수
func = (str) => {
    console.log(str);
}
func("08. 함수가 실행되었습니다.");

// 기존 매개변수 익명 함수
const func1 = function (str){
    console.log(str);
}
func1("08. 함수가 실행되었습니다.");

// 화살표 매개변수 익명 함수
const func1 = (str) => {
    console.log(str);
}
func1("08. 함수가 실행되었습니다.");
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            08. 함수가 실행되었습니다.<br>
                            08. 함수가 실행되었습니다.<br>
                            08. 함수가 실행되었습니다.<br>
                            08. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample01 -->
        </div>

        <div class="main__sample container">
            <div id="sample09" class="sample">
                <h3>09. 화살표 함수 : 리턴값 함수</h3>
                <p>
                    "리턴값 함수"라는 용어는 함수가 실행된 후 결과를 반환하는 함수를 의미합니다. 함수가 실행을 마치고 나면, 결과값을 반환하게 되는데, 이 반환되는 값이 "리턴값"이라고 합니다.
                    기존 리턴값 함수에서 function을 지운 후 func1과 () 사이엔 '=' ,()와 {} 사이엔 '=>'를 입력합니다.
                </p>
                <pre><code>{
// 기존 리턴값 선언적 함수
function func = (){
    return "09. 함수가 실행되었습니다.";
}
console.log(func());

// 화살표 리턴값 선언적 함수
func = () => {
    return "09. 함수가 실행되었습니다.";
}
console.log(func());

// 기존 리턴값 익명 함수
const func1 = function (){
    return "09. 함수가 실행되었습니다.";
}
console.log(func1());

// 화살표 리턴값 익명 함수
const func1 = () => {
    return "09. 함수가 실행되었습니다.";
}
console.log(func1());
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            09. 함수가 실행되었습니다.<br>
                            09. 함수가 실행되었습니다.<br>
                            09. 함수가 실행되었습니다.<br>
                            09. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample10" class="sample">
                <h3>10. 화살표 함수 : 매개함수 + 리턴값 함수</h3>
                <p>

                    "매개함수 + 리턴값 함수"라는 용어는 매개변수를 받는 함수와 리턴값을 반환하는 함수를 함께 언급하는 것으로 이해할 수 있습니다. 이는 함수가 입력값을 받아들이고, 그 입력값을
                    처리한 후 결과를 반환하는 기본적인 함수의 형태를 의미합니다.
                    기존 매개변수 + 리턴값 함수에서 function을 지운 후 func1과 () 사이엔 '=' ,()와 {} 사이엔 '=>'를 입력합니다.
                    1. 만약 매개변수가 하나라면 ()는 생략이 가능합니다.
                    2. 만약 매개변수가 하나라면 (), {}, return은 생략이 가능합니다.
                    3. 만약 선언적 함수를 쓰게 될 경우 익명 함수에서 const, (), {}, return은 생략이 가능합니다. 단, 가독성은 떨어집니다.
                </p>
                <pre><code>{
// 익명 함수(화살표 함수) + 매개변수 + 리턴값
const func = (str) => {
    return str;
}
console.log(func("10. 함수가 실행되었습니다."));

// 매개변수가 하나이면 () 생략 가능
const func2 = str => {
    return str;
}
console.log(func2("10. 함수가 실행되었습니다."));

// {},리턴 생략 가능
const func3 = str => str;
console.log(func3("10. 함수가 실행되었습니다."));

// 선언적 함수를 쓰게 될 경우 const 생략 가능 but, 가독성이 없음
func4 = str => str;
console.log(func4("10. 함수가 실행되었습니다."));
                    
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            10. 함수가 실행되었습니다.<br>
                            10. 함수가 실행되었습니다.<br>
                            10. 함수가 실행되었습니다.<br>
                            10. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample11" class="sample">
                <h3>11. 함수 유형 : 함수와 매개변수를 이용한 형태</h3>
                <p>
                    func 함수는 두 개의 매개변수 num과 str을 가지고 있습니다.
                    이 함수는 두 개의 console.log 문을 사용하여 두 가지 형식으로 문자열을 출력할 수 있는데,
                    첫 번째, 연결 연산자(+)를 사용하여 문자열을 연결하게 되면 num + ". " + str의 형태로 출력됩니다.
                    두 번째, console.log 문은 템플릿 리터럴인 ${num}. ${str}의 형태를 사용하여 문자열을 출력합니다.
                </p>
                <pre><code>{
function func(num, str) {
    console.log(num + ". " + str);
    console.log(`${num}. ${str}`);
}
func(11, "함수가 실행되었습니다.");
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            11. 함수가 실행되었습니다.<br>
                            11. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample12" class="sample">
                <h3>12. 함수 유형 : 함수와 변수를 이용한 형태</h3>
                <p>
                    const 키워드를 사용하여 num에는 12를, str에는 "함수가 실행되었습니다."를 변수로 지정한 후 func라는 이름의 함수를 정의합니다.
                    이 때 func는 두 개의 매개변수인 num과 str을 받게 되며, 템플릿 리터럴인 ${num}. ${str}의 형태를 사용하면 두 개를 조합한 문자열을 출력하게 됩니다.
                </p>
                <pre><code>{
const num = 12;
const str = "함수가 실행되었습니다.";

function func(num, str) {
    console.log(`${num}. ${str}`);
}
func(num, str);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            12. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>


        <div class="main__sample container">
            <div id="sample13" class="sample">
                <h3>13. 함수 유형 : 함수와 배열을 이용한 형태</h3>
                <p>
                    const 키워드를 사용하여 배열로 num에는 13, 14를, str에는 "함수가 실행되었습니다.", "함수가 실행되었습니다."를 변수로 지정한 후 func라는 이름의 함수를
                    템플릿 리터럴 형태로 정의합니다.
                    배열이기 때문에 num[0]과 str[0], num[1]과 str[1]에 해당하는 요소를 따로 불러와야 결과값이 도출됩니다.
                </p>
                <pre><code>{
const num = [13, 14];
const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."];

function func(num, str) {
console.log(`${num}.${str}`);
}
func(num[0], str[0]);
func(num[1], str[1]);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            13. 함수가 실행되었습니다.<br>
                            14. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample14" class="sample">
                <h3>14. 함수 유형 : 함수와 객체를 이용한 형태</h3>
                <p>

                    "매개함수 + 리턴값 함수"라는 용어는 매개변수를 받는 함수와 리턴값을 반환하는 함수를 함께 언급하는 것으로 이해할 수 있습니다. 이는 함수가 입력값을
                    받아들이고, 그 입력값을
                    처리한 후 결과를 반환하는 기본적인 함수의 형태를 의미합니다.
                    const 키워드를 사용하여 객체로 num에는 15를, str에는 "함수가 실행되었습니다."를 변수로 지정한 후 func라는 이름의 함수를 템플릿 리터럴 형태로 정의합니다.
                    이 때, info라는 객체를 생성한 후 변수를 지정했기 때문에 .num과 .str에 해당하는 info 요소를 각각 불러와야 결과값이 도출됩니다.
                </p>
                <pre><code>{
const info = {
num: 15,
str: "함수가 실행되었습니다."
}

function func(num, str) {
console.log(`${num}.${str}`);
}
func(info.num, info.str);}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            15. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample15" class="sample">
                <h3>15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</h3>
                <p>
                    const 키워드를 사용하여 객체로 num에는 16, 17을, str에는 "함수가 실행되었습니다.", "함수가 실행되었습니다."를 변수로 지정한 후 func라는 이름의 함수를
                    템플릿 리터럴 형태로 정의합니다.
                    이 때, info는 배열로, num과 str은 객체로 지정했기 때문에 배열인 info 요소와 객체인 .num과 .str의 요소를 각각 불러와야 결과값이 도출됩니다.
                </p>
                <pre><code>{
const info = [
{ num: 16, str: "함수가 실행되었습니다." },
{ num: 17, str: "함수가 실행되었습니다." },
];
function func(num, str) {
console.log(`${num}.${str}`);
}
func(info[0].num, info[0].str);
func(info[1].num, info[1].str);</code></pre>
                }<div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            16. 함수가 실행되었습니다.<br>
                            17. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample16" class="sample">
                <h3>16. 함수 유형 : 객체 안에 함수를 이용한 형태</h3>
                <p>
                    이 형태는 JavaScript에서 객체 내부에 함수를 포함시켜 사용하는 것을 의미합니다. 이것은 객체 지향 프로그래밍의 중요한 특징 중 하나인 "캡슐화"를 구현하는 방법 중
                    하나입니다.

                    JavaScript에서는 객체의 속성(property)으로 함수를 정의할 수 있습니다. 이렇게 정의된 함수는 해당 객체에 종속되어 있으며, 그 객체에 속한 다른 속성들과 마찬가지로
                    사용될 수 있습니다.

                    예를 들어, 아래의 코드에서 객체 info 안에 result라는 함수를 정의했습니다.
                </p>
                <pre><code>{
const info = {
num: 18,
str: "함수가 실행되었습니다.",
result: () => {
console.log(`${info.num}.${info.str}`);
}
}
info.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            18. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
                <div class="result">
                    <details>
                        <summary>해설</summary>
                        <div>
                            const info = {: 이 줄은 객체 info를 선언하고 초기화합니다.<br>

                            num: 18,: info 객체 안에 num이라는 속성을 정의하고 그 값으로 18을 할당합니다.<br>

                            str: "함수가 실행되었습니다.",: info 객체 안에 str이라는 속성을 정의하고 그 값으로 문자열 "함수가 실행되었습니다."를 할당합니다.<br>

                            result: () => {: info 객체 안에 result라는 속성을 정의합니다. 이 속성은 화살표 함수로 정의되어 있습니다. 화살표 함수는 특정 동작을
                            수행하고자 할 때 사용됩니다.<br>

                            console.log(${info.num}.${info.str});: result 함수의 몸통 부분입니다. 여기서는 console.log()를 사용하여 문자열 템플릿
                            리터럴을 이용하여 info 객체의 num 속성과 str 속성을 출력합니다. 이 때, info.num과 info.str은 객체 info 안에 있는 값을 참조합니다.

                            }: 함수 정의를 마칩니다.<br>

                            info.result();: info 객체 안에 있는 result 함수를 호출합니다. 이는 앞서 정의한 result 함수의 동작을 수행합니다. 따라서 이 코드를
                            실행하면 콘솔에 "18.함수가 실행되었습니다."가 출력됩니다.<br>

                            이렇게 객체 안에 함수를 포함시키는 것은 객체 지향 프로그래밍에서 자주 사용되는 기법 중 하나입니다. 객체의 상태와 해당 상태를 조작할 수 있는 동작(메서드)을 함께
                            묶어 관리할 수 있습니다.<br>
                        </div>
                    </details>
                </div>
            </div>
        </div>
        </div>

        <div class="main__sample container">
            <div id="sample17" class="sample">
                <h3>17. 함수 유형 : 객체 생성자 함수</h3>
                <p>
                    객체 생성자 함수는 JavaScript에서 객체를 생성하기 위한 함수입니다. 이 함수를 사용하면 동일한 유형의 객체를 반복해서 만들 수 있습니다. 객체 생성자 함수는 클래스(ES6
                    이전에는 기본적인 클래스 개념이 없었기 때문에)와 유사한 역할을 합니다.
                </p>
                <pre><code>{
//함수 정의
function Func(num, str) {
this.num = num;  //'this'는 자기 자신을 의미
this.str = str;
this.result = () => {
console.log(`${this.num}.${this.str}`);
}
}
//인스턴스 생성
const info1 = new Func(19, "함수가 실행되었습니다.");
const info2 = new Func(20, "함수가 실행되었습니다.");

// 호출
info1.result();
info2.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            19. 함수가 실행되었습니다.<br>
                            20. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample18" class="sample">
                <h3>18. 함수 유형 : 프로토타입 함수</h3>
                <p>
                    익명 함수(Anonymous function)는 이름이 없는 함수를 의미합니다. 일반적으로 프로그래밍 언어에서 함수는 함수명을
                    가지고 있어서 함수를 정의하고 호출할 때 그 함수명을
                    사용합니다. 그러나 익명 함수는 이름 없이 정의되며, 주로 다른 함수의 매개변수로 전달되거나, 함수 내부에서 간단한 연산을 수행할
                    때 사용됩니다.
                </p>
                <pre><code>{
//함수 정의
function Func(num, str) {
this.num = num;
this.str = str;
}

//메서드 추가
Func.prototype.result = function () {
console.log(`${this.num}.${this.str}`);
}

//인스턴스 생성
const info1 = new Func(21, "함수가 실행되었습니다.");
const info2 = new Func(22, "함수가 실행되었습니다.");

// 호출
info1.result();
info2.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            21. 함수가 실행되었습니다.<br>
                            22. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample19" class="sample">
                <h3>19. 함수 유형 : 객체 리터릴 함수</h3>
                <p>
                    1. 함수 정의를 통해 두 개의 매개변수 num과 str을 받습니다. 이 때, this 키워드를 사용하여 새로운 객체의 속성으로 num과 str을 설정합니다.
                    이 때, this는 자기 자신을 의미합니다.
                    2. Func.prototype을 사용하여 Func 함수의 프로토타입에 result1, result2라는 새로운 메서드를 추가합니다. 이 때, 각각의 메서드들을 객체 리터럴을 통해
                    그룹화했기 때문에 코드가 더 구조화되고 관리하기 쉽다는 장점이 있습니다.
                    3. new 키워드를 사용하여 Func 함수를 호출하여 info1과 info2라는 두 개의 새로운 객체를 생성합니다. 이를 인스턴스라 부르고, 인스턴스는 각각의 다른 값들을 가지고
                    있습니다.
                    4. result 메서드를 실행하면 info1.result1()과 info2.result2()요소에 해당하는 결과값을 도출합니다.
                </p>
                <pre><code>{
// 함수 정의
function Func(num, str) {
    this.num = num;
    this.str = str;
}

// 메서드 추가 - 추가된 메서드가 많아지면서 객체 리터럴을 통해 그룹화
Func.prototype = {
    result1: function () {
        console.log(`${this.num}. ${this.str}`);
    },
    result2: function () {
        console.log(`${this.num}. ${this.str}`);
    }
}

// 인스턴스 생성
const info1 = new Func(23, "함수가 실행되었습니다.");
const info2 = new Func(24, "함수가 실행되었습니다.");

// 호출
info1.result1();
info2.result2();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            23. 함수가 실행되었습니다.<br>
                            24. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>




        <div class="main__sample container">
            <div id="sample20" class="sample">
                <h3>20. 함수 : 즉시실행 함수</h3>
                <p>
                    즉시 실행 함수(IIFE, Immediately Invoked Function Expression)는 JavaScript에서 사용되는 함수 표현식 중 하나입니다. 이름 그대로,
                    함수가 선언되자마자 즉시 실행됩니다.

                    일반적으로 함수는 선언되면 필요할 때 호출되어야 합니다. 그러나 IIFE는 선언됨과 동시에 실행되므로 다른 함수와 구별됩니다. 이것은 주로 함수 스코프를 생성하여 변수가 함수
                    내부에만 존재하도록 하거나 전역 스코프의 오염을 피하기 위해 사용됩니다.
                </p>
                <pre><code>{
(function () {
    console.log("15. 함수가 실행되었습니다.");
})();


//화살표 함수

(() => {
    console.log("16. 함수가 실행되었습니다.");
})();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            15. 함수가 실행되었습니다.<br>
                            16. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample21" class="sample">
                <h3>21. 함수 : 피라미터 함수</h3>
                <p>
                    이 코드는 두 가지 방식으로 함수를 정의하고 호출하는 예제를 보여줍니다.
                    하나는 일반적인 함수 정의 방식이고, 다른 하나는 화살표 함수를 사용한 방식입니다.<br>
                    1.일반적인 함수 정의 방식:<br>
                    이 부분은 기본값을 갖는 매개변수를 사용하여 함수를 정의합니다. str이라는 매개변수가 정의되어 있으며, 이 매개변수는 문자열 "17. 함수가 실행되었습니다."를 기본값으로
                    갖습니다. 함수 내에서는 받은 매개변수 str을 콘솔에 출력합니다. 함수를 호출할 때 별도의 인자를 전달하지 않으면 기본값이 사용됩니다. 따라서 func()를 호출하면 "17.
                    함수가 실행되었습니다."가 콘솔에 출력됩니다.<br>
                    2. 화살표 함수를 사용한 함수 정의 방식:<br>
                    이 부분은 화살표 함수를 사용하여 함수를 정의합니다. 화살표 함수는 매개변수를 받고 그 매개변수를 출력하는 기능을 수행합니다. 이 함수 역시 str이라는 매개변수를 가지며,
                    기본값으로 "18. 함수가 실행되었습니다."를 설정합니다. 함수를 호출할 때 인자를 전달하지 않으면 기본값이 사용되어 "18. 함수가 실행되었습니다."가 콘솔에 출력됩니다.

                    이러한 예제는 함수 정의 시에 기본값을 설정하여 호출할 때 인자를 전달하지 않아도 되도록 하는 방법을 보여줍니다.

                </p>
                <pre><code>{
function func(str = "17. 함수가 실행되었습니다.") {
    console.log(str);
}
func();


const func1 = (str = "18. 함수가 실행되었습니다.") => {
    console.log(str);
}
func1();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            17. 함수가 실행되었습니다.<br>
                            18. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample22" class="sample">
                <h3>22. 함수 : 재귀 함수</h3>
                <p>

                    재귀 함수(recursive function)는 함수가 자신을 호출하는 것을 의미합니다. 즉, 함수 내에서 자기 자신을 호출하는 과정을 포함합니다.

                    재귀 함수는 일반적으로 두 가지 부분으로 구성됩니다:<br>

                    베이스 케이스(Base case): 재귀 함수에서는 반드시 종료 조건을 정의해야 합니다. 이 조건이 충족되면 함수가 더 이상 재귀적으로 호출되지 않고 종료됩니다. 이는 무한 루프를
                    방지하고 함수 실행을 제어하는 데 중요합니다.<br>

                    재귀 케이스(Recursive case): 함수가 자신을 호출하는 부분입니다. 이 부분에서는 일반적으로 문제를 더 작은 단위로 분할하고, 자기 자신을 호출하여 문제를 해결합니다.
                </p>
                <pre><code>{
//01 반복문을 사용하는 경우
function func(num) {
    for (let i = 0; i < num; i++) {
        console.log("19. 함수가 실행되었습니다.");
    }
}
func(10);

//02 재귀함수를 사용하기
function func1(num) {
    if (num < 1) return;

    console.log("20.실행되었습니다.")
    func1(num - 1);  //재귀호출
}
func1(10);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            19. 함수가 실행되었습니다.<br>
                            20. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample23" class="sample">
                <h3>23. 함수 : 콜백 함수</h3>
                <p>
                    // 작업이 순서대로<br>
                    // 코드는 위에서 아래로 순차적으로 진행.<br>
                    // 한 작업이 끝나면 다음 작업이 시작<br>

                    콜백 함수(callback function)는 다른 함수의 인자로 전달되어 실행되는 함수입니다. 즉, 콜백 함수는 다른 함수 내에서 호출되는 함수입니다.

                    JavaScript에서 콜백 함수는 주로 비동기적인 작업을 처리하고, 이벤트 핸들링에 사용됩니다. 예를 들어, 타이머 함수인 setTimeout은 특정 시간이 지난 후에 콜백
                    함수를 실행하는 데 사용될 수 있습니다. 또한, 이벤트 리스너에 콜백 함수를 등록하여 이벤트가 발생했을 때 실행되도록 할 수도 있습니다.

                    콜백 함수를 사용하면 비동기적인 작업을 조율하고, 코드를 더욱 유연하게 만들 수 있습니다. 다음은 간단한 콜백 함수의 예제입니다:
                <pre><code>{
{
    //01 이벤트
    function func() {
        console.log("21.실행되었습니다.");
    }
    // btn.addEventListener("click, func");

    //02 함수를 다른 함수의 인자로 전달
    function func1() {
        console.log("22.실행되었습니다.");
    }
    function func2(callback) {
        callback();
    }
    func2(func1);
}

//03 반복문을 사용하는 경우
function func3(num) {
    console.log(num + ".실행되었습니다.");
}
function func4(callback) {
    for (let i = 23; i < 28; i++) {
        callback(i);
    }
}
func4(func3);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            22.실행되었습니다.<br>
                            23.실행되었습니다.<br>
                            24.실행되었습니다.<br>
                            25.실행되었습니다.<br>
                            26.실행되었습니다.<br>
                            27.실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample24" class="sample">
                <h3>24. 함수 : 비동기 방식 : 콜백 함수</h3>
                <p>
                    작업이 순서와 관계없이 여러 작업 처리할 수 있음<br>
                    // 콜백함수, 프로미스, async/await 등을 사용하여 작업이 완료될 때까지 대기하지 않고 다른 작업을 진행할 수 있음<br>
                </p>
                <pre><code>{
    function func1() {
        console.log("29.실행되었습니다.");
    }
    function func2() {
        console.log("30.실행되었습니다.");
    }
    func1();
    func2();

    //02 비동기적인 함수 호출
    function func3() {
        setTimeout(() => {
            console.log("31.실행되었습니다.");
        }, 1000)
    }
    function func4() {
        console.log("32.실행되었습니다.");
    }
    func3();
    func4();

    //03 콜백함수 비동기 호출
    {
        {
            function func5(callback) {
                setTimeout(() => {
                    console.log("33.실행되었습니다.");
                    callback();
                }, 1000);
            }
            function func6() {
                console.log("34.실행되었습니다.");
            }
            func5(function () {
                func6();
            });
        }
    }
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            29.실행되었습니다.<br>
                            30.실행되었습니다.<br>
                            32.실행되었습니다.<br>
                            Live reload enabled.<br>
                            31.실행되었습니다.<br>
                            33.실행되었습니다.<br>
                            34.실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample25" class="sample">
                <h3>25. 함수 : 비동기 방식 : 프로미스</h3>
                <p>
                    프로미스(Promise)는 JavaScript에서 비동기 작업을 보다 효율적으로 다룰 수 있도록 도와주는 객체입니다. 프로미스는 비동기 작업이 완료되었을 때
                    결과값이나 실패 원인을 처리할 수 있도록 합니다.<br>
                    프로미스는 세 가지 상태를 가질 수 있습니다:<br>
                    대기(pending): 초기 상태로, 작업이 완료되지 않은 상태입니다.<br>
                    이행(fulfilled): 작업이 성공적으로 완료된 상태입니다.<br>
                    거부(rejected): 작업이 실패한 상태입니다.<br>
                    프로미스를 생성할 때는 new Promise()를 사용합니다. 그리고 그 안에는 비동기 작업이 포함된 함수를 전달합니다. <br>
                    이 함수는 두 개의 매개변수인 resolve와 reject를 받습니다. 이 함수들은 각각 작업이 성공할 때와 실패할 때 호출됩니다.
                </p>
                <pre><code>{

}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>

                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample26" class="sample">
                <h3>26. 함수 : 비동기 방식 : asyne/await</h3>
                <p>
                    async/await는 JavaScript에서 비동기 작업을 처리하는 데 사용되는 문법입니다. 이 문법은 프로미스를 기반으로 하며, 비동기 코드를 작성하고 읽기 쉽고 유지보수하기
                    쉬운 형태로 변환할 수 있도록 도와줍니다.

                    async 함수:
                    async 함수는 비동기 작업을 수행하는 함수를 정의할 때 사용됩니다. async 함수를 정의하면 해당 함수는 항상 프로미스를 반환합니다. 이 함수 내에서 await 키워드를
                    사용하여 프로미스가 처리될 때까지 기다릴 수 있습니다.
                </p>
                <pre><code>{
    {
        // 01 : 일반적인 함수(동기방식)
        function func() {
            console.log("35. 실행되었습니다.")
        }
        func();

        // 02 : 함수(비동기방식)
        async function func2() {
            console.log("36. 실행되었습니다.")
        }
        func2();

        // 03 : 비동기 방식(fetch())
        async function func3() {
            const result = await fetch("https://webs9919.github.io/class2024/json/gineungsaJC2005_02.json");
            const data = await result.json();
            console.log(data);
        }
        func3()

        // 04 : 비동기 + 에러
        async function func4() {
            try {
                const result = await fetch("https://webs9919.github.io/class2024/json/gineungsaJC2005_02.json");
                const data = await result.json();
                console.log(data);
            } catch (error) {
                console.error(error);
            }
        }
        func4()
    }
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            35.실행되었습니다.<br>
                            36.실행되었습니다.<br>
                            Live reload enabled.<br>
                            Array(60)<br>
                            Array(60)
                        </div>
                    </details>
                </div>
            </div>
        </div>



        <div class="main__sample container">
            <div id="sample27" class="sample">
                <h3>27. 함수 : 중첩 함수</h3>
                <p>

                </p>
                <pre><code>{

}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>

                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample28" class="sample">
                <h3>28. 함수 : 클로저</h3>
                <p>

                </p>
                <pre><code>{

}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>

                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample29" class="sample">
                <h3>29. 클래스 : 기본</h3>
                <p>

                </p>
                <pre><code>{

}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>

                        </div>
                    </details>
                </div>
            </div>
        </div>

        <div class="main__sample container">
            <div id="sample30" class="sample">
                <h3>30. 클래스 : 상속</h3>
                <p>

                </p>
                <pre><code>{

}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>

                        </div>
                    </details>
                </div>
            </div>
        </div>





    </main>
    <!-- //main -->

    <footer id="footer">

    </footer>
    <!-- //footer -->

    <script src="assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>



        // 01. 함수 : 선언적 함수
        {
            function func() {
                console.log("01. 함수 : 선언적 함수");
            }
            func()
        }

        // 02. 함수 : 익명 함수
        {
            const func = function () {
                console.log("02. 함수 : 익명 함수");
            }
            func()
        }
        // 03. 함수 : 매개변수 함수
        {
            function func(str) {
                console.log("03. 함수 : 매개변수 함수")
            }
            func()
        }

        {
            const func1 = function (str) {
                console.log("03. 함수 : 매개변수 함수")
            }
            func()
        }
        // 04. 함수 : 리턴값 함수
        {
            function func() {
                return "04. 함수 : 리턴값 함수"
            }
            console.log(func())
        }

        {
            const func2 = function () {
                return "04. 함수 : 리턴값 함수"
            }
            console.log(func2())
        }

        // // 05. 함수 : 매개함수 + 
        {
            function func(str) {
                return str;
            }
            console.log(func())
        }

        {
            const func2 = function (str) {
                return str;
            }
            console.log(func2)
        }

        // 06. 화살표 함수 : 선언적 함수
        {
            func = () => {
                console.log("06.화살표 함수 : 선언적 함수")
            }
            func()
        }
        // 07. 화살표 함수 : 익명 함수
        {
            const func = () => {
                console.log("07. 화살표 함수 : 익명 함수")
            }
            func()
        }
        // 08. 화살표 함수 : 매개변수 함수
        // 09. 화살표 함수 : 리턴값 함수
        // 10. 화살표 함수 : 매개함수 + 리턴값 함수

        // 11. 함수 유형 : 함수와 매개변수를 이용한 형태
        {
            function func(num, str) {
                console.log(num + "." + str);
                console.log(`${num}.${str}`);
            }
            func(11, "함수가 실행되었습니다.");
        }

        // 12. 함수 유형 : 함수와 변수를 이용한 형태
        {
            const num = 12;
            const str = "함수가 실행되었습니다.";

            function func(num, str) {
                console.log(`${num}.${str}`);
            }
            func(num, str);
        }

        // 13. 함수 유형 : 함수와 배열을 이용한 형태
        {
            const num = [13, 14];
            const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."];

            function func(num, str) {
                console.log(`${num}.${str}`);
            }
            func(num[0], str[0]);
            func(num[1], str[1]);
        }
        // 14. 함수 유형 : 함수와 객체를 이용한 형태
        {
            const info = {
                num: 15,
                str: "함수가 실행되었습니다."
            }

            function func(num, str) {
                console.log(`${num}.${str}`);
            }
            func(info.num, info.str);
        }
        // 15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태
        {
            const info = [
                { num: 16, str: "함수가 실행되었습니다." },
                { num: 17, str: "함수가 실행되었습니다." },
            ];
            function func(num, str) {
                console.log(`${num}.${str}`);
            }
            func(info[0].num, info[0].str);
            func(info[1].num, info[1].str);
        }
        // 16. 함수 유형 : 객체 안에 함수를 이용한 형태
        {
            const info = {
                num: 18,
                str: "함수가 실행되었습니다.",
                result: () => {
                    console.log(`${info.num}.${info.str}`);
                }
            }
            info.result();
        }
        // 17. 함수 유형 : 객체 생성자 함수
        {
            //함수 정의
            function Func(num, str) {
                this.num = num;  //'this'는 자기 자신을 의미
                this.str = str;
                this.result = () => {
                    console.log(`${this.num}.${this.str}`);
                }
            }
            //인스턴스 생성
            const info1 = new Func(19, "함수가 실행되었습니다.");
            const info2 = new Func(20, "함수가 실행되었습니다.");

            // 호출
            info1.result();
            info2.result();
        }

        // 18. 함수 유형 : 프로토타입 함수
        {
            //함수 정의
            function Func(num, str) {
                this.num = num;
                this.str = str;
            }

            //메서드 추가
            Func.prototype.result = function () {
                console.log(`${this.num}.${this.str}`);
            }

            //인스턴스 생성
            const info1 = new Func(21, "함수가 실행되었습니다.");
            const info2 = new Func(22, "함수가 실행되었습니다.");

            // 호출
            info1.result();
            info2.result();

        }
        // 19. 함수 유형 : 객체 리터릴 함수
        {


            //객체생성자 함수는 앞글자 대문자
            // let i = num;         
            // let i = str; 
            // function Func(num, str) {  

            // this.num = num;
            // this.str = str;
            // }
            //* 위에 let 대신 객체생성자 함수를 만들고 this를 써줌
            // }


            //함수 정의
            function Func(num, str) {

                this.num = num;
                this.str = str;
            }

            //메서드 추가

            Func.prototype = {
                result1: function () {
                    console.log(`${this.num}.${this.str}`);
                },
                result2: function () {
                    console.log(`${this.num}.${this.str}`);
                },
            }

            //인스턴스 생성
            const info1 = new Func(23, "함수가 실행되었습니다.");
            const info2 = new Func(24, "함수가 실행되었습니다.");

            // 호출
            info1.result1();
            info2.result2();
        }

        // 11. 함수 유형 : 함수와 매개변수를 이용한 형태
        {
            function func(x, y) {
                console.log(x, y);
            }
            func("01", "실행되었습니다.");
        }
        // 12. 함수 유형 : 함수와 변수를 이용한 형태
        {
            const x = "02.", y = "실행되었습니다"

            function func(x, y) {
                console.log(x, y);
            }
            func(x, y)
        }
        // 13. 함수 유형 : 함수와 배열을 이용한 형태
        {
            const x = ["03.", "04."];
            const y = "실행되었습니다."

            function func(x, y) {
                console.log(x, y);
            }
            func(x[0], y);
            func(x[1], y);
        }
        // 14. 함수 유형 : 함수와 객체를 이용한 형태
        {
            const x = {
                a: "05.",
                b: "실행되었습니다."
            }
            function func(x, y) {
                console.log(x, y);
            }
            func(x.a, x.b);
        }
        // 15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태
        {
            const info = [
                { a: "06", b: "실행되었습니다." },
                { c: "07", d: "실행되었습니다." }
            ];
            function func(x, y) {
                console.log(x, y);
            }
            func(info[0].a, info[0].a);
            func(info[1].c, info[1].d);

        }
        // 16. 함수 유형 : 객체 안에 함수를 이용한 형태
        {
            const info = {
                num: "08",
                str: "실행되었습니다.",
                result: () => {
                    console.log(info.num + "." + info.str);
                    console.log(`${info.num}.${info.str}`);
                }
            }
            info.result();
        }
        // 17. 함수 유형 : 객체 생성자 함수
        {
            function Func(num, str) {
                this.num = num;
                this.str = str;
                this.result = () => {
                    console.log(`${this.num}.${this.str}`);
                }
            }

            //인스턴스 생성
            const info1 = new Func("09", "실행되었습니다.");
            const info2 = new Func("10", "실행되었습니다.");

            //호출
            info1.result();
            info2.result();
        }
        // 18. 함수 유형 : 프로토타입 함수
        {
            //함수정의
            function Func(num, str) {
                this.num = num;
                this.str = str;
            }

            //메서드 추가
            Func.prototype.result = function () {
                console.log(`${this.num}.${this.str}`);
            }
            //인스턴스 생성
            const info1 = new Func("11", "실행되었습니다.");
            const info2 = new Func("12", "실행되었습니다.");

            //호출
            info1.result();
            info2.result();
        }
        // 19. 함수 유형 : 객체 리터럴 함수
        {
            //함수정의
            function Func(num, str) {
                this.num = num;
                this.str = str;
            }

            //메서드 추가
            Func.prototype = {
                result1: function () {
                    console.log(`${this.num}. ${this.str}`);
                },
                result2: function () {
                    console.log(`${this.num}. ${this.str}`);
                }
            }

            //인스턴스 생성
            const info1 = new Func("13", "실행되었습니다.");
            const info2 = new Func("14", "실행되었습니다.");

            //호출
            info1.result1();
            info2.result2();
        }

        // 20. 함수 : 즉시실행 함수
        {
            (function () {
                console.log("15. 함수가 실행되었습니다.");
            })();


            //화살표 함수

            (() => {
                console.log("16. 함수가 실행되었습니다.");
            })();
        }

        // 21. 함수 : 피라미터 함수
        {
            function func(str = "17. 함수가 실행되었습니다.") {
                console.log(str);
            }
            func();


            const func1 = (str = "18. 함수가 실행되었습니다.") => {
                console.log(str);
            }
            func1();
        }

        // 22. 함수 : 재귀 함수
        {
            //01 반복문을 사용하는 경우
            function func(num) {
                for (let i = 0; i < num; i++) {
                    console.log("19. 함수가 실행되었습니다.");
                }
            }
            func(10);

            //02 재귀함수를 사용하기
            function func1(num) {
                if (num < 1) return;

                console.log("20.실행되었습니다.")
                func1(num - 1);  //재귀호출
            }
            func1(10);
        }
        // 23. 함수 : 콜백 함수
        {
            {
                //01 이벤트
                function func() {
                    console.log("21.실행되었습니다.");
                }
                // btn.addEventListener("click, func");

                //02 함수를 다른 함수의 인자로 전달
                function func1() {
                    console.log("22.실행되었습니다.");
                }
                function func2(callback) {
                    callback();
                }
                func2(func1);
            }

            //03 반복문을 사용하는 경우
            function func3(num) {
                console.log(num + ".실행되었습니다.");
            }
            function func4(callback) {
                for (let i = 23; i < 28; i++) {
                    callback(i);
                }
            }
            func4(func3);
        }



        // 24. 함수 : 비동기 방식 : 콜백 함수

        // 동기 : 
        // 작업이 순서대로
        // 코드는 위에서 아래로 순차적으로 진행.
        // 한 작업이 끝나면 다음 작업이 시작


        // 비동기 : 
        // 작업이 순서와 관계없이 여러 작업 처리할 수 있음
        // 콜백함수, 프로미스, async/await 등을 사용하여 작업이 완료될 때까지 대기하지 않고 다른 작업을 진행할 수 있음

        //01 동기적인 함수 호출
        {
            function func1() {
                console.log("29.실행되었습니다.");
            }
            function func2() {
                console.log("30.실행되었습니다.");
            }
            func1();
            func2();

            //02 비동기적인 함수 호출
            function func3() {
                setTimeout(() => {
                    console.log("31.실행되었습니다.");
                }, 1000)
            }
            function func4() {
                console.log("32.실행되었습니다.");
            }
            func3();
            func4();

            //03 콜백함수 비동기 호출
            {
                {
                    function func5(callback) {
                        setTimeout(() => {
                            console.log("33.실행되었습니다.");
                            callback();
                        }, 1000);
                    }
                    function func6() {
                        console.log("34.실행되었습니다.");
                    }
                    func5(function () {
                        func6();
                    });
                }
            }
        }

        // 25. 함수 : 비동기 방식 : 프로미스
        // {
        //     const func = new Promise(resolve, reject => {
        //         if (data) {
        //             resolve("35.실행되었습니다.");
        //         } else {
        //             reject("36.실행되었습니다.");
        //         }
        //     });
        //         .then(
        //             result => document.write(result)
        //         )
        //         .catch(
        //             error => document.write(error)
        //         )
        // }

        // 26. 함수 : 비동기 방식 : asyne/await
        {

            // 01 : 일반적인 함수(동기방식)
            function func() {
                console.log("35. 실행되었습니다.")
            }
            func();

            // 02 : 함수(비동기방식)
            async function func2() {
                console.log("36. 실행되었습니다.")
            }
            func2();

            // 03 : 비동기 방식(fetch())
            async function func3() {
                const result = await fetch("https://webs9919.github.io/class2024/json/gineungsaJC2005_02.json");
                const data = await result.json();
                console.log(data);
            }
            func3()

            // 04 : 비동기 + 에러
            async function func4() {
                try {
                    const result = await fetch("https://webs9919.github.io/class2024/json/gineungsaJC2005_02.json");
                    const data = await result.json();
                    console.log(data);
                } catch (error) {
                    console.error(error);
                }
            }
            func4()
        }
        // 27. 함수 : 중첩 함수</a></li>
        // 28.
        // 29. 클래스 : 기본</a></li>
        // 30. 클래스 : 상속</a></li>

    </script>

</body>

</html>